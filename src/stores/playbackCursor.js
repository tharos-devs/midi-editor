// stores/playbackCursor.js - Store global pour le curseur de lecture
import { ref, computed, watch } from 'vue'
import { defineStore } from 'pinia'
import { useMidiStore } from './midi'
import { useUIStore } from './ui'
import { useTimeSignature } from '@/composables/useTimeSignature'

export const usePlaybackCursorStore = defineStore('playbackCursor', () => {
  const midiStore = useMidiStore()
  const uiStore = useUIStore()
  const { timeToPixelsWithSignatures } = useTimeSignature()

  // √âtat global du curseur
  const currentTime = ref(0)
  const isPlaying = ref(false)
  const isPaused = ref(false)
  const totalDuration = ref(0)
  
  // Timer interne
  let internalTimer = null
  let timerStartTime = 0
  let timerStartMusicTime = 0

  // Configuration
  const config = ref({
    latencyCompensation: 0.050 // 50ms
  })

  // Position en pixels calcul√©e
  const pixelPosition = computed(() => {
    if (!timeToPixelsWithSignatures || currentTime.value <= 0) return 0
    
    // Compensation de latence seulement pendant la lecture (soustraire la latence)
    const adjustedTime = (isPlaying.value && currentTime.value > 0) 
      ? currentTime.value - config.value.latencyCompensation 
      : currentTime.value
    
    return Math.max(0, timeToPixelsWithSignatures(adjustedTime))
  })

  // D√©marrer le curseur
  function startPlayback() {
    if (isPlaying.value) return
    
    console.log('üöÄ STORE: D√©marrage curseur global')
    isPlaying.value = true
    isPaused.value = false
    
    startTimer()
  }

  // Arr√™ter le curseur
  function pausePlayback() {
    if (!isPlaying.value) return
    
    console.log('‚è∏Ô∏è STORE: Pause curseur global')
    isPlaying.value = false
    isPaused.value = true
    
    stopTimer()
  }

  // Stop complet
  function stopPlayback() {
    console.log('‚èπÔ∏è STORE: Stop curseur global')
    console.trace('‚ö†Ô∏è STACK TRACE - qui appelle stopPlayback ?')
    isPlaying.value = false
    isPaused.value = false
    currentTime.value = 0
    
    stopTimer()
  }

  // Stop en fin de morceau (garde la position)
  function stopAtEnd() {
    const finalPosition = currentTime.value
    console.log('üèÅ STORE: Fin de morceau - arr√™t sans reset √†', finalPosition.toFixed(2) + 's')
    isPlaying.value = false
    isPaused.value = false
    // NE PAS remettre currentTime.value = 0
    
    stopTimer()
    
    // V√©rification que la position reste intacte
    setTimeout(() => {
      if (currentTime.value !== finalPosition) {
        console.warn('‚ö†Ô∏è POSITION CHANG√âE APR√àS stopAtEnd!', {
          avant: finalPosition.toFixed(2) + 's',
          apr√®s: currentTime.value.toFixed(2) + 's'
        })
      } else {
        console.log('‚úÖ Position maintenue apr√®s stopAtEnd:', currentTime.value.toFixed(2) + 's')
      }
    }, 100)
  }

  // Seek
  function seekTo(time, fromTimelineClick = false) {
    // S'assurer que la dur√©e totale est √† jour - CORRECTION: utiliser la vraie dur√©e
    const { getLastMidiEventTime } = useTimeSignature()
    const realDuration = getLastMidiEventTime?.value || midiStore.getTotalDuration
    
    if (realDuration && realDuration > 0) {
      totalDuration.value = realDuration
    }
    
    // CORRECTION: Ne pas limiter le temps lors du seek manuel
    // Laisser l'utilisateur positionner le curseur o√π il veut sur la timeline
    const clampedTime = Math.max(0, time) // Seulement >= 0, pas de limite max
    currentTime.value = clampedTime
    
    // Debug: totalWidth utilis√© par le store au moment du seek
    const { totalWidth: timeSignatureTotalWidth } = useTimeSignature()
    console.log(`üéØ Seek${fromTimelineClick ? ' (Timeline Click)' : ''}: ${clampedTime.toFixed(6)}s ‚Üí ${pixelPosition.value.toFixed(1)}px`, {
      storeTotalWidth: timeSignatureTotalWidth?.value || 'undefined',
      pixelPos: pixelPosition.value.toFixed(1),
      tempsOriginal: time.toFixed(6) + 's',
      dur√©e: totalDuration.value?.toFixed(6) + 's',
      limit√©: time > (totalDuration.value || 0) ? '‚ö†Ô∏è NON LIMIT√â' : '‚úÖ DANS LIMITES',
      source: fromTimelineClick ? 'TIMELINE_CLICK' : 'PLAYER_SEEK'
    })
    
    // CORRECTION: D√©clencher l'auto-scroll SEULEMENT si le curseur est hors de la zone visible
    // apr√®s un seek manuel pour s'assurer qu'il reste visible
    setTimeout(() => {
      const scrollController = document.querySelector('.scroll-controller')
      const timelineScroll = document.querySelector('.timeline-scroll')
      const referenceElement = scrollController || timelineScroll
      
      if (referenceElement) {
        const containerWidth = referenceElement.clientWidth
        const currentScrollLeft = referenceElement.scrollLeft
        const cursorPos = pixelPosition.value
        
        const leftBound = currentScrollLeft
        const rightBound = currentScrollLeft + containerWidth
        const isVisible = cursorPos >= leftBound && cursorPos <= rightBound
        
        console.log('üîç V√©rification visibilit√© curseur:', {
          curseur: cursorPos.toFixed(1) + 'px',
          scroll: currentScrollLeft.toFixed(1) + 'px',
          zoneVisible: leftBound.toFixed(1) + '-' + rightBound.toFixed(1) + 'px',
          visible: isVisible ? '‚úÖ VISIBLE' : '‚ùå HORS √âCRAN'
        })
        
        if (!isVisible) {
          // Calculer les limites de scroll possibles
          const maxScrollLeft = Math.max(0, 2640 - containerWidth) // Timeline 2640px - largeur √©cran
          const idealScrollLeft = Math.max(0, cursorPos - containerWidth / 2) // Curseur au centre
          const newScrollLeft = Math.min(idealScrollLeft, maxScrollLeft) // Ne pas d√©passer le max
          
          console.log('üîß Ajustement scroll pour visibilit√©:', {
            id√©al: idealScrollLeft.toFixed(1) + 'px',
            maximum: maxScrollLeft.toFixed(1) + 'px',
            appliqu√©: newScrollLeft.toFixed(1) + 'px'
          })
          
          // Forcer le scroll sur TOUS les √©l√©ments synchronis√©s
          const scrollController = document.querySelector('.scroll-controller')
          if (scrollController) {
            scrollController.scrollLeft = newScrollLeft
            console.log('‚úÖ Scroll appliqu√© sur ScrollController')
          }
          
          document.querySelectorAll('.sync-scroll-x').forEach((element, index) => {
            element.scrollLeft = newScrollLeft
            console.log(`‚úÖ Scroll appliqu√© sur √©l√©ment ${index}: ${element.className}`)
          })
          
          // V√©rification apr√®s application
          setTimeout(() => {
            const finalScrollLeft = referenceElement.scrollLeft
            const finalRightBound = finalScrollLeft + containerWidth
            const finalVisible = cursorPos >= finalScrollLeft && cursorPos <= finalRightBound
            
            console.log('üîç V√©rification finale:', {
              scrollDemand√©: newScrollLeft.toFixed(1) + 'px',
              scrollObtenu: finalScrollLeft.toFixed(1) + 'px',
              diff√©rence: (newScrollLeft - finalScrollLeft).toFixed(1) + 'px',
              curseurMaintenant: finalVisible ? '‚úÖ VISIBLE' : '‚ùå TOUJOURS HORS √âCRAN',
              zoneFinale: finalScrollLeft.toFixed(1) + '-' + finalRightBound.toFixed(1) + 'px',
              curseurPos: cursorPos.toFixed(1) + 'px'
            })
            
            // CORRECTION ULTIME: Si le curseur est encore invisible apr√®s scroll max,
            // c'est qu'il est √† la toute fin. Reculer le curseur l√©g√®rement.
            if (!finalVisible && cursorPos >= 2640 - 10) { // Si tr√®s proche de la fin
              console.log('üîß CORRECTION ULTIME: Curseur trop proche de la fin, ajustement visuel')
              // Reculer le curseur de quelques pixels pour qu'il soit visible
              const adjustedPosition = Math.max(0, finalRightBound - 20) // 20px avant le bord droit
              console.log('üìç Position ajust√©e:', adjustedPosition.toFixed(1) + 'px')
              
              // Pas id√©al mais n√©cessaire pour la visibilit√©
              // TODO: Am√©liorer l'UX en ajustant la largeur de la timeline
            }
          }, 50)
        }
      }
    }, 100)
    
    if (isPlaying.value) {
      startTimer() // Red√©marrer le timer avec le nouveau temps
    }
  }
  
  // Fonction pour d√©clencher l'auto-scroll vers la position du curseur
  function triggerAutoScroll() {
    // CORRECTION: D√©sactiver compl√®tement l'auto-scroll lors des clics manuels
    // L'auto-scroll ne devrait se d√©clencher que pendant la lecture automatique
    if (!isPlaying.value) {
      console.log(`üìç Auto-scroll ignor√©: pas en lecture (seek manuel)`)
      return
    }
    
    const cursorPixelPos = pixelPosition.value
    
    // CORRECTION: Utiliser le ScrollController comme r√©f√©rence principale
    const scrollController = document.querySelector('.scroll-controller')
    const firstElement = document.querySelector('.sync-scroll-x')
    
    // Priorit√© au ScrollController pour la position de scroll
    const referenceElement = scrollController || firstElement
    
    if (!referenceElement) {
      console.warn('Aucun √©l√©ment de r√©f√©rence trouv√© pour l\'auto-scroll')
      return
    }
    
    const containerWidth = referenceElement.clientWidth
    const currentScrollLeft = referenceElement.scrollLeft
    
    // Calculer les limites de la zone visible avec padding
    const padding = 100
    const leftBound = currentScrollLeft + padding
    const rightBound = currentScrollLeft + containerWidth - padding
    
    // V√©rifier si le curseur est hors de la zone visible
    if (cursorPixelPos < leftBound || cursorPixelPos > rightBound) {
      // Positionner le curseur √† 30% de la zone visible (plus de marge √† droite)
      const cursorOffsetFromLeft = containerWidth * 0.3
      const newScrollLeft = Math.max(0, cursorPixelPos - cursorOffsetFromLeft)
      
      console.log(`üìç Auto-scroll: ${currentScrollLeft.toFixed(0)}px ‚Üí ${newScrollLeft.toFixed(0)}px (curseur: ${cursorPixelPos.toFixed(0)}px, largeur: ${containerWidth}px)`)
      
      // Approche plus directe: forcer le scroll sur TOUS les √©l√©ments imm√©diatement
      document.querySelectorAll('.sync-scroll-x').forEach(element => {
        element.scrollLeft = newScrollLeft
        console.log(`üîß Scroll forc√© sur ${element.className}: ${newScrollLeft}px`)
      })
      
      // Forcer aussi le ScrollController
      const scrollController = document.querySelector('.scroll-controller')
      if (scrollController) {
        scrollController.scrollLeft = newScrollLeft
        console.log(`üîß Scroll forc√© sur ScrollController: ${newScrollLeft}px`)
      }
      
      console.log(`üìç Auto-scroll appliqu√©: curseur √† ${cursorPixelPos.toFixed(0)}px, nouveau scroll: ${newScrollLeft.toFixed(0)}px`)
    } else {
      console.log(`üìç Curseur visible (${cursorPixelPos.toFixed(0)}px dans zone ${leftBound.toFixed(0)}-${rightBound.toFixed(0)}px)`)
    }
  }

  // Timer interne
  function startTimer() {
    if (internalTimer) clearInterval(internalTimer)
    
    timerStartTime = performance.now()
    timerStartMusicTime = currentTime.value
    
    internalTimer = setInterval(() => {
      if (!isPlaying.value) return
      
      const now = performance.now()
      const realTimeElapsed = (now - timerStartTime) / 1000
      const newMusicTime = timerStartMusicTime + realTimeElapsed
      
      if (newMusicTime <= totalDuration.value) {
        currentTime.value = newMusicTime
        
        // Debug p√©riodique
        if (Math.floor(newMusicTime * 10) % 20 === 0) {
          console.log('üéØ CURSEUR GLOBAL:', {
            temps: newMusicTime.toFixed(2) + 's',
            pixels: pixelPosition.value.toFixed(1) + 'px'
          })
        }
      } else {
        // Fin de morceau
        currentTime.value = totalDuration.value
        stopAtEnd()
      }
    }, 16) // 60fps
  }

  function stopTimer() {
    if (internalTimer) {
      clearInterval(internalTimer)
      internalTimer = null
    }
  }

  // Initialisation
  function initialize() {
    // CORRECTION: Utiliser la vraie dur√©e qui inclut TOUS les √©v√©nements MIDI
    const { getLastMidiEventTime } = useTimeSignature()
    totalDuration.value = getLastMidiEventTime?.value || midiStore.getTotalDuration || 0
    
    // S'assurer que le curseur est visible m√™me apr√®s un restart
    // CORRECTION: Ne pas forcer √† 0 si le curseur a une position (apr√®s stopAtEnd)
    if (currentTime.value === 0 && !isPlaying.value) {
      // Force la r√©activit√© de la position seulement si vraiment √† 0
      const originalTime = currentTime.value
      currentTime.value = 0.001
      setTimeout(() => {
        // V√©rifier si le temps n'a pas chang√© entre temps (par exemple par stopAtEnd)
        if (currentTime.value === 0.001) {
          currentTime.value = originalTime // Garder la position originale
        }
      }, 10)
    }
    
    console.log('üéØ STORE: Curseur initialis√© - dur√©e:', totalDuration.value + 's', 'position:', currentTime.value.toFixed(2) + 's')
  }

  // Watcher pour debug pixelPosition (logs r√©duits)
  watch(() => pixelPosition.value, (newPos, oldPos) => {
    // Log seulement pour les changements significatifs
    if (Math.abs(newPos - (oldPos || 0)) > 1) {
      console.log('üìç Curseur: ' + newPos?.toFixed(1) + 'px (' + currentTime.value.toFixed(2) + 's)')
    }
  })

  return {
    // √âtat
    currentTime,
    isPlaying,
    isPaused,
    totalDuration,
    pixelPosition,
    config,
    
    // Actions
    startPlayback,
    pausePlayback,
    stopPlayback,
    stopAtEnd,
    seekTo,
    initialize
  }
})