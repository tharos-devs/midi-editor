// composables/useMidiRecording.js - Gestion de l'enregistrement MIDI en temps r√©el

import { ref, computed, onMounted, onUnmounted, watch } from 'vue'
import { useMidiStore } from '@/stores/midi'
import { useProjectStore } from '@/stores/project'
import { useMidiManager } from '@/composables/useMidiManager'
import { useMidiPlayer } from '@/composables/useMidiPlayer'

export function useMidiRecording() {
  const midiStore = useMidiStore()
  const projectStore = useProjectStore()
  const midiManager = useMidiManager()
  const midiPlayer = useMidiPlayer()

  // √âtat de l'enregistrement
  const isRecording = ref(false)
  const recordingTrackId = ref(null)
  const recordedEvents = ref([])
  const midiInputListeners = ref(new Map())
  
  // √âtat global d'armement d'enregistrement
  const isRecordArmed = ref(false)
  
  // Flag global pour bloquer compl√®tement l'enregistrement
  const recordingBlocked = ref(false)
  
  // ID de session d'enregistrement pour invalider les anciens listeners
  let recordingSessionId = 0

  // Fonctions utilitaires
  function createNoteId() {
    return 'recorded-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9)
  }

  // Gestion du monitoring MIDI (passthrough input ‚Üí output)
  function handleMidiMonitoring(trackId, midiData) {
    // Trouver la piste correspondante
    const track = midiStore.tracks.find(t => t.id === trackId)
    if (!track || !track.monitor) return // ‚úÖ CORRECTION: Ne monitorer que si activ√©

    // V√©rifier si la piste a une sortie configur√©e
    const outputId = track.midiOutput || 'default'
    const trackChannel = track.channel || 0

    // Rediriger le message MIDI vers la sortie de la piste
    if (midiManager.midiSupported?.value) {
      // Modifier le canal MIDI si n√©cessaire
      const modifiedData = [...midiData]
      const status = midiData[0] & 0xF0
      const originalChannel = midiData[0] & 0x0F
      
      // Appliquer le canal de la piste si c'est un message avec canal
      if (status >= 0x80 && status <= 0xEF) {
        modifiedData[0] = status | trackChannel
      }

      // Envoyer vers la sortie MIDI
      const success = midiManager.sendMidiMessage(outputId, modifiedData)
      
      // Log minimal seulement en cas de probl√®me
      if (!success) {
        console.log(`‚ùå Monitoring MIDI √©chec: Track ${trackId} ‚Üí ${outputId}`)
      }
    }
  }

  // G√©rer les √©v√©nements MIDI entrants
  function handleMidiMessage(trackId, event, sessionId = 0) {
    const data = event.data
    const timestamp = event.timeStamp || performance.now()
    
    // √âMISSION D'√âV√âNEMENT D'ACTIVIT√â MIDI pour les indicateurs visuels
    window.dispatchEvent(new CustomEvent('midi-activity', {
      detail: { trackId, timestamp }
    }))
    
    // MONITORING MIDI : Rediriger vers la sortie seulement si Monitor activ√©
    handleMidiMonitoring(trackId, data)
    
    // V√âRIFICATIONS CRITIQUES : Plusieurs niveaux de protection avec logs d√©taill√©s
    if (sessionId !== recordingSessionId) {
      console.log(`üö´ MIDI ignor√©: session obsol√®te (${sessionId} vs ${recordingSessionId})`)
      return
    }
    
    if (recordingBlocked.value) {
      console.log(`üö´ MIDI ignor√©: enregistrement bloqu√© (trackId=${trackId})`)
      return
    }
    
    if (!isRecording.value) {
      console.log(`üö´ MIDI ignor√©: enregistrement arr√™t√© (trackId=${trackId})`)
      return
    }
    
    // V√âRIFICATION CRITIQUE: V√©rifier si le lecteur MIDI est en pause
    if (midiPlayer.isPaused?.value) {
      console.log(`üö´ MIDI ignor√©: lecteur en pause (trackId=${trackId})`)
      return
    }
    
    // Obtenir le temps actuel depuis une variable globale mise √† jour par le player
    let recordTime = window.currentPlaybackTime || 0

    // D√©coder le message MIDI
    const status = data[0] & 0xF0
    const channel = data[0] & 0x0F
    const note = data[1]
    const velocity = data[2]
    
    // ENREGISTREMENT : Seulement si la piste a Record activ√© ET enregistrement global en cours
    const track = midiStore.tracks.find(t => t.id === trackId)
    const shouldRecord = track?.record && isRecording.value && !recordingBlocked.value
    
    if (!shouldRecord) {
      // Si on ne devrait pas enregistrer, ne pas traiter l'√©v√©nement du tout
      return
    }
    
    // MODE REPLACE : Pas de suppression continue ici, seulement au moment de la r√©ception d'√©v√©nements
    
    console.log(`üîç Debug Record: trackId=${trackId} track.record=${track?.record} isRecording=${isRecording.value} shouldRecord=${shouldRecord}`)
    
    console.log(`üé§ ENREGISTREMENT: Status=${status.toString(16)} Channel=${channel + 1} Note=${note} Vel=${velocity} Time=${recordTime.toFixed(3)}s`)

    switch (status) {
      case 0x90: // Note On
        if (velocity > 0) {
          handleNoteOn(trackId, channel, note, velocity, recordTime, timestamp)
        } else {
          // Velocity 0 = Note Off
          handleNoteOff(trackId, channel, note, recordTime, timestamp)
        }
        break

      case 0x80: // Note Off
        handleNoteOff(trackId, channel, note, recordTime, timestamp)
        break

      case 0xB0: // Control Change
        handleControlChange(trackId, channel, data[1], data[2], recordTime, timestamp)
        break

      case 0xE0: // Pitch Bend
        const pitchValue = (data[2] << 7) + data[1] - 8192
        handlePitchBend(trackId, channel, pitchValue, recordTime, timestamp)
        break
    }
  }

  // Map pour tracker les notes en cours
  const activeNotes = ref(new Map())

  function handleNoteOn(trackId, channel, note, velocity, recordTime, timestamp) {
    // V√âRIFICATION CRITIQUE: Bloquer si enregistrement arr√™t√©
    if (recordingBlocked.value || !isRecording.value) {
      console.log(`üö´ handleNoteOn BLOQU√â: recordingBlocked=${recordingBlocked.value}, isRecording=${isRecording.value}`)
      return
    }
    
    const noteKey = `${trackId}-${channel}-${note}`
    
    // MODE REPLACE : Supprimer les √©v√©nements existants au moment pr√©cis de la r√©ception d'une note MIDI
    if (projectStore.userPreferences.keyboard.recordingMode === 'replace') {
      console.log(`üóëÔ∏è Replace: suppression notes existantes au moment de r√©ception √† ${recordTime.toFixed(3)}s`)
      const timeWindow = 0.05 // 50ms de fen√™tre
      clearEventsAtTime(trackId, 'note', recordTime, timeWindow)
    }
    
    // V√©rifier si c'est le premier √©v√©nement Note pour cette piste
    const eventTracker = window.eventTrackers?.get(trackId) || new Set()
    const isFirstNoteEvent = !eventTracker.has('note')
    
    if (isFirstNoteEvent) {
      console.log(`üéµ Premier √©v√©nement Note re√ßu pour piste ${trackId} √† ${recordTime.toFixed(3)}s`)
      
      // Marquer que cette piste re√ßoit maintenant des √©v√©nements Note
      eventTracker.add('note')
      window.eventTrackers?.set(trackId, eventTracker)
    }
    
    // Si une note identique est d√©j√† active, la terminer d'abord
    if (activeNotes.value.has(noteKey)) {
      const existingNote = activeNotes.value.get(noteKey)
      const duration = Math.max(0.1, recordTime - existingNote.startTime)
      finalizeNote(existingNote.id, duration)
    }

    // Cr√©er une nouvelle note
    const noteId = createNoteId()
    const noteData = {
      id: noteId,
      trackId: trackId,
      midi: note,
      velocity: velocity / 127, // Convertir en format 0-1
      time: recordTime,
      startTime: recordTime,
      channel: channel,
      timestamp: timestamp
    }

    // Stocker la note active
    activeNotes.value.set(noteKey, noteData)

    console.log(`üéµ Note On enregistr√©e: ${note} (${noteId}) √† ${recordTime.toFixed(3)}s`)
  }

  function handleNoteOff(trackId, channel, note, recordTime, timestamp) {
    // V√âRIFICATION CRITIQUE: Bloquer si enregistrement arr√™t√©
    if (recordingBlocked.value || !isRecording.value) {
      console.log(`üö´ handleNoteOff BLOQU√â: recordingBlocked=${recordingBlocked.value}, isRecording=${isRecording.value}`)
      return
    }
    
    const noteKey = `${trackId}-${channel}-${note}`
    
    if (activeNotes.value.has(noteKey)) {
      const noteData = activeNotes.value.get(noteKey)
      const currentTime = window.currentPlaybackTime || 0
      const duration = Math.max(0.1, currentTime - noteData.startTime)
      
      // Finaliser la note
      finalizeNote(noteData.id, duration)
      
      // Supprimer de la map des notes actives
      activeNotes.value.delete(noteKey)

      console.log(`üéµ Note Off enregistr√©e: ${note} dur√©e=${duration.toFixed(3)}s`)
    }
  }

  function finalizeNote(noteId, duration) {
    // V√âRIFICATION CRITIQUE: Bloquer si enregistrement arr√™t√©
    if (recordingBlocked.value || !isRecording.value) {
      console.log(`üö´ finalizeNote BLOQU√â: recordingBlocked=${recordingBlocked.value}, isRecording=${isRecording.value}`)
      return
    }
    
    const noteData = [...activeNotes.value.values()].find(n => n.id === noteId)
    if (!noteData) return

    // Cr√©er la note compl√®te
    const completeNote = {
      id: noteId,
      trackId: noteData.trackId,
      midi: noteData.midi,
      velocity: noteData.velocity,
      time: noteData.time,
      duration: duration
    }

    // TRACE: Log avant ajout direct au store
    console.log(`‚ûï DIRECT PUSH vers midiStore.notes:`, {
      noteId: completeNote.id,
      midi: completeNote.midi,
      time: completeNote.time,
      duration: completeNote.duration,
      recordingBlocked: recordingBlocked.value,
      isRecording: isRecording.value,
      stack: new Error().stack.split('\n').slice(1, 3).join('\n')
    })
    
    // Ajouter au store
    midiStore.notes.push(completeNote)
    
    console.log(`‚úÖ Note enregistr√©e: ${completeNote.midi} dur√©e=${duration.toFixed(3)}s`)
    
    // Ajouter aux √©v√©nements enregistr√©s pour le suivi
    recordedEvents.value.push({
      type: 'note',
      timestamp: Date.now(),
      data: completeNote
    })

    // D√©clencher la r√©activit√©
    midiStore.triggerReactivity('midi-recording-note')
  }

  function handleControlChange(trackId, channel, controller, value, recordTime, timestamp) {
    // V√âRIFICATION CRITIQUE: Bloquer si enregistrement arr√™t√©
    if (recordingBlocked.value || !isRecording.value) {
      console.log(`üö´ handleControlChange BLOQU√â: recordingBlocked=${recordingBlocked.value}, isRecording=${isRecording.value}`)
      return
    }
    
    // MODE REPLACE : Supprimer les √©v√©nements existants au moment pr√©cis de la r√©ception d'un CC MIDI
    if (projectStore.userPreferences.keyboard.recordingMode === 'replace') {
      console.log(`üóëÔ∏è Replace: suppression CC${controller} existants au moment de r√©ception √† ${recordTime.toFixed(3)}s`)
      const timeWindow = 0.05 // 50ms de fen√™tre
      clearEventsAtTime(trackId, 'cc', recordTime, timeWindow, controller)
    }
    
    // V√©rifier si c'est le premier √©v√©nement CC de ce num√©ro pour cette piste
    const eventTracker = window.eventTrackers?.get(trackId) || new Set()
    const ccKey = `cc${controller}`
    const isFirstCCEvent = !eventTracker.has(ccKey)
    
    if (isFirstCCEvent) {
      console.log(`üéõÔ∏è Premier √©v√©nement CC${controller} re√ßu pour piste ${trackId} √† ${recordTime.toFixed(3)}s`)
      
      // Marquer que cette piste re√ßoit maintenant des √©v√©nements CC de ce num√©ro
      eventTracker.add(ccKey)
      window.eventTrackers?.set(trackId, eventTracker)
    }
    
    // Cr√©er l'√©v√©nement CC avec les bons types
    const ccEvent = {
      id: createNoteId(),
      trackId: trackId, // Garder en number
      controller: controller.toString(), // String pour coh√©rence avec CCLane
      value: value.toString(), // String pour coh√©rence
      time: recordTime.toString(), // String pour coh√©rence
      channel: channel,
      lastModified: Date.now()
    }

    // Utiliser la m√©thode du store au lieu de push direct
    midiStore.addCC({
      trackId: trackId,
      controller: controller.toString(),
      time: recordTime,
      value: value,
      channel: channel
    })

    console.log(`‚úÖ CC enregistr√©: CC${controller}=${value}`)

    // Ajouter aux √©v√©nements enregistr√©s
    recordedEvents.value.push({
      type: 'cc',
      timestamp: Date.now(),
      data: ccEvent
    })
  }

  function handlePitchBend(trackId, channel, pitchValue, recordTime, timestamp) {
    // Pour l'instant, on peut logger les pitch bends
    console.log(`üéöÔ∏è Pitch Bend: ${pitchValue} √† ${recordTime.toFixed(3)}s`)
    
    // TODO: Impl√©menter le stockage des pitch bends si n√©cessaire
  }

  // Configuration des listeners d'input MIDI (MONITORING + ENREGISTREMENT)
  function setupMidiInputListening() {
    // Nettoyer les anciens listeners
    clearMidiInputListeners()

    console.log('üé§ Configuration des listeners MIDI pour enregistrement/monitoring...')
    console.log('üîç √âtat enregistrement:', { 
      isRecording: isRecording.value, 
      recordingBlocked: recordingBlocked.value 
    })

    // Parcourir toutes les pistes pour configurer les inputs
    midiStore.tracks.forEach(track => {
      const inputId = track.midiInput
      console.log(`üìç Piste ${track.id}: input="${inputId}" record=${track.record} monitor=${track.monitor}`)
      
      if (!inputId || inputId === 'none') {
        if (track.record && !recordingBlocked.value) {
          console.warn(`‚ö†Ô∏è Piste ${track.id} a Record activ√© mais aucun input MIDI configur√© !`)
        }
        return
      }

      // ‚úÖ CORRECTION: Ne configurer les listeners que si Record OU Monitor activ√©
      // Mais pour Record, v√©rifier aussi que l'enregistrement n'est pas bloqu√©
      const shouldSetupRecord = track.record && !recordingBlocked.value
      const shouldSetupMonitor = track.monitor
      
      if (!shouldSetupRecord && !shouldSetupMonitor) {
        console.log(`‚è≠Ô∏è Piste ${track.id} ignor√©e (Record et Monitor d√©sactiv√©s ou enregistrement bloqu√©)`)
        return
      }

      console.log(`üéß Configuration input pour piste ${track.id} (record=${shouldSetupRecord}, monitor=${shouldSetupMonitor})...`)

      // D√©terminer si on a besoin d'enregistrement ou seulement monitoring
      const monitoringOnly = !shouldSetupRecord && shouldSetupMonitor

      if (inputId === 'all') {
        // √âcouter tous les inputs
        const availableInputs = midiManager.availableInputs?.value || []
        console.log(`üéß Piste ${track.id}: √©coute TOUS les inputs (${availableInputs.length} disponibles)`)
        availableInputs.forEach(input => {
          setupInputListener(track.id, input.input, monitoringOnly)
        })
      } else {
        // √âcouter un input sp√©cifique
        const input = midiManager.availableInputs?.value?.find(i => i.id === inputId)
        if (input?.input) {
          console.log(`üéß Piste ${track.id}: √©coute input sp√©cifique "${input.name}"`)
          setupInputListener(track.id, input.input, monitoringOnly)
        } else {
          console.error(`‚ùå Input MIDI "${inputId}" non trouv√© pour piste ${track.id}`)
        }
      }
    })
  }

  // Configuration automatique du monitoring (appel√© d√®s qu'une piste change d'input)
  function setupMidiMonitoring() {
    console.log('üîä Configuration du monitoring MIDI...')
    setupMidiInputListening()
  }

  function setupInputListener(trackId, midiInput, monitoringOnly = false) {
    const listenerKey = `${trackId}-${midiInput.id}`
    
    // √âviter les doublons
    if (midiInputListeners.value.has(listenerKey)) {
      console.log(`‚ö†Ô∏è Listener d√©j√† configur√©: ${listenerKey}`)
      return
    }

    // Cr√©er un listener diff√©rent selon le mode
    let listener
    if (monitoringOnly) {
      // Listener UNIQUEMENT pour le monitoring
      listener = (event) => {
        // √âMISSION D'√âV√âNEMENT D'ACTIVIT√â MIDI pour les indicateurs visuels
        window.dispatchEvent(new CustomEvent('midi-activity', {
          detail: { trackId, timestamp: event.timeStamp || performance.now() }
        }))
        
        handleMidiMonitoring(trackId, event.data)
      }
      console.log(`üéß Listener MONITORING configur√©: piste ${trackId} <- input "${midiInput.name}"`)
    } else {
      // Listener complet (monitoring + enregistrement)
      const currentSessionId = recordingSessionId
      listener = (event) => handleMidiMessage(trackId, event, currentSessionId)
      console.log(`üé§ Listener COMPLET configur√©: piste ${trackId} <- input "${midiInput.name}" (session=${currentSessionId})`)
    }
    
    midiInput.addEventListener('midimessage', listener)
    midiInputListeners.value.set(listenerKey, {
      input: midiInput,
      listener: listener,
      trackId: trackId,
      sessionId: monitoringOnly ? -1 : recordingSessionId,
      monitoringOnly: monitoringOnly
    })
  }

  function clearMidiInputListeners() {
    const listenerCount = midiInputListeners.value.size
    console.log(`üßπ Nettoyage de ${listenerCount} listeners MIDI...`)
    
    midiInputListeners.value.forEach((config, key) => {
      console.log(`üßπ Suppression listener: ${key} (piste ${config.trackId})`)
      config.input.removeEventListener('midimessage', config.listener)
    })
    midiInputListeners.value.clear()
    console.log(`‚úÖ ${listenerCount} listeners MIDI nettoy√©s`)
  }

  // Armer/D√©sarmer l'enregistrement
  function setRecordArmed(armed) {
    isRecordArmed.value = armed
    console.log(`üé§ Enregistrement ${armed ? 'arm√©' : 'd√©sarm√©'}`)
  }

  function toggleRecordArmed() {
    setRecordArmed(!isRecordArmed.value)
  }

  // Supprimer les √©v√©nements dans un petit intervalle au moment pr√©cis de la r√©ception (mode Replace)
  function clearEventsAtTime(trackId, eventType, currentTime, timeWindow, ccNumber = null) {
    const fromTime = currentTime - timeWindow
    const toTime = currentTime + timeWindow
    
    console.log(`üóëÔ∏è Replace instant: suppression ${eventType} dans fen√™tre ${fromTime.toFixed(3)}s ‚Üí ${toTime.toFixed(3)}s`)
    
    if (eventType === 'note') {
      // Supprimer les notes existantes dans la fen√™tre temporelle
      const notesToKeep = midiStore.notes.filter(note => {
        // Garder si ce n'est pas la bonne piste
        if (note.trackId !== trackId) return true
        
        // Garder si la note est compl√®tement en dehors de la fen√™tre
        const noteEndTime = note.time + (note.duration || 0)
        return noteEndTime <= fromTime || note.time >= toTime
      })
      
      const notesRemoved = midiStore.notes.length - notesToKeep.length
      midiStore.notes = notesToKeep
      
      if (notesRemoved > 0) {
        console.log(`üóëÔ∏è Replace instant: ${notesRemoved} notes supprim√©es de la piste ${trackId} √† ${currentTime.toFixed(3)}s`)
      }
      
    } else if (eventType === 'cc' && ccNumber !== null) {
      // Supprimer les CC dans la fen√™tre temporelle
      const ccToKeep = midiStore.midiCC.filter(cc => {
        // Garder si ce n'est pas la bonne piste
        if (parseInt(cc.trackId) !== trackId) return true
        
        // Garder si ce n'est pas le bon num√©ro de CC
        if (parseInt(cc.controller) !== ccNumber) return true
        
        // Garder si le CC est en dehors de la fen√™tre
        const ccTime = parseFloat(cc.time)
        return ccTime < fromTime || ccTime >= toTime
      })
      
      const ccRemoved = midiStore.midiCC.length - ccToKeep.length
      midiStore.midiCC = ccToKeep
      
      if (ccRemoved > 0) {
        console.log(`üóëÔ∏è Replace instant: ${ccRemoved} CC${ccNumber} supprim√©s de la piste ${trackId} √† ${currentTime.toFixed(3)}s`)
      }
    }
    
    // D√©clencher la r√©activit√© seulement si quelque chose a chang√©
    if (eventType === 'note' || eventType === 'cc') {
      midiStore.triggerReactivity('selective-replace')
    }
  }

  // Ancienne fonction pour compatibilit√© (mode replace global - non utilis√©e maintenant)
  function clearExistingEvents(startTime, endTime, mode = 'merge', recordingTrackIds = []) {
    // Cette fonction n'est plus utilis√©e en mode replace s√©lectif
    console.log(`üóëÔ∏è Ancienne fonction clearExistingEvents appel√©e - non utilis√©e en mode s√©lectif`)
  }

  // D√©marrer l'enregistrement
  function startRecording(trackId = null, mode = 'merge') {
    console.log(`üî¥ D√âBUT ENREGISTREMENT...`)
    
    // Incr√©menter l'ID de session pour invalider les anciens listeners
    recordingSessionId++
    console.log(`üÜî Nouvelle session d'enregistrement: ${recordingSessionId}`)
    
    // D√©bloquer l'enregistrement et le d√©marrer
    recordingBlocked.value = false
    isRecording.value = true
    recordingTrackId.value = trackId
    recordedEvents.value = []
    activeNotes.value.clear()

    // Initialiser les trackers d'enregistrement s√©lectif pour tous les modes
    window.recordStartTime = window.currentPlaybackTime || 0
    // Collecter les IDs des pistes qui ont Record activ√©
    window.recordingTrackIds = midiStore.tracks
      .filter(track => track.record)
      .map(track => track.id)
    
    // Initialiser les trackers d'√©v√©nements re√ßus (pour Merge et Replace)
    window.eventTrackers = new Map() // trackId -> Set de types d'√©v√©nements re√ßus
    
    if (mode === 'replace') {
      console.log(`üóëÔ∏è Mode Replace: Pistes arm√©es pour enregistrement s√©lectif:`, window.recordingTrackIds)
    } else {
      console.log(`üéµ Mode Merge: Pistes arm√©es pour enregistrement s√©lectif:`, window.recordingTrackIds)
    }

    // Configurer les listeners
    setupMidiInputListening()

    console.log(`üî¥ Enregistrement d√©marr√©${trackId ? ` sur track ${trackId}` : ''} (mode: ${mode})`)
  }

  // Arr√™ter l'enregistrement
  function stopRecording(mode = 'merge') {
    console.log(`‚èπÔ∏è STOP RECORDING: Arr√™t de l'enregistrement en cours...`)
    
    // CRITIQUE: BLOQUER l'enregistrement IMM√âDIATEMENT avant toute autre action
    recordingBlocked.value = true
    isRecording.value = false
    
    // Incr√©menter l'ID de session pour invalider TOUS les listeners existants
    recordingSessionId++
    console.log(`üÜî Session invalid√©e: ${recordingSessionId} (tous anciens listeners ignor√©s)`)
    
    console.log(`üö´ Enregistrement BLOQU√â - plus aucun √©v√©nement ne sera trait√©`)
    
    // Calculer la zone temporelle d'enregistrement
    const startTime = window.recordStartTime || 0
    const stopTime = window.currentPlaybackTime || 0
    
    console.log(`‚èπÔ∏è Zone d'enregistrement: ${startTime.toFixed(3)}s ‚Üí ${stopTime.toFixed(3)}s`)
    
    // En mode Replace: la suppression a √©t√© faite au moment de la r√©ception des premiers √©v√©nements
    if (mode === 'replace') {
      console.log(`üóëÔ∏è Mode Replace: suppressions effectu√©es lors de la r√©ception des √©v√©nements (curseur qui passe)`)
    }
    
    // Finaliser toutes les notes actives AVANT de bloquer compl√®tement
    console.log(`‚èπÔ∏è Finalisation FORC√âE des notes actives √† ${stopTime.toFixed(3)}s`)
    
    activeNotes.value.forEach((noteData, noteKey) => {
      const duration = Math.max(0.1, stopTime - noteData.startTime)
      
      // Finaliser SANS v√©rifier recordingBlocked car on est en train d'arr√™ter
      const completeNote = {
        id: noteData.id,
        trackId: noteData.trackId,
        midi: noteData.midi,
        velocity: noteData.velocity,
        time: noteData.time,
        duration: duration
      }
      
      // TRACE: Log avant ajout direct au store (finalisation forc√©e)
      console.log(`‚ûï DIRECT PUSH FORC√â vers midiStore.notes:`, {
        noteId: completeNote.id,
        midi: completeNote.midi,
        time: completeNote.time,
        duration: completeNote.duration,
        recordingBlocked: recordingBlocked.value,
        isRecording: isRecording.value,
        reason: "finalisation_forcee_stop",
        stack: new Error().stack.split('\n').slice(1, 3).join('\n')
      })
      
      // Ajouter directement au store
      midiStore.notes.push(completeNote)
      console.log(`üéµ Note finalis√©e FORC√âE: ${completeNote.midi} dur√©e=${duration.toFixed(3)}s`)
      
      // Ajouter aux √©v√©nements enregistr√©s
      recordedEvents.value.push({
        type: 'note',
        timestamp: Date.now(),
        data: completeNote
      })
    })
    activeNotes.value.clear()
    
    // D√©clencher la r√©activit√© pour les notes finalis√©es
    midiStore.triggerReactivity('midi-recording-note')
    
    // IMPORTANT: Nettoyer COMPL√àTEMENT les listeners d'enregistrement
    console.log(`üßπ Nettoyage COMPLET des listeners d'enregistrement...`)
    clearMidiInputListeners()
    
    // Nettoyer les trackers d'enregistrement s√©lectif IMM√âDIATEMENT
    if (window.recordStartTime !== undefined) {
      console.log(`üßπ Nettoyage des trackers d'enregistrement s√©lectif (mode: ${mode})`)
      delete window.recordStartTime
      delete window.recordingTrackIds
      delete window.eventTrackers
      delete window.replacementTrackers
    }
    
    recordingTrackId.value = null
    
    // IMMEDIATE: Reconfigurer les listeners pour monitoring uniquement SANS d√©lai
    console.log(`üîÑ Reconfiguration IMM√âDIATE des listeners pour monitoring uniquement`)
    setupMidiInputListening()

    const eventCount = recordedEvents.value.length
    console.log(`‚úÖ Enregistrement compl√®tement arr√™t√© - ${eventCount} √©v√©nements captur√©s (mode: ${mode})`)

    return recordedEvents.value
  }

  // Propri√©t√©s calcul√©es
  const recordedEventCount = computed(() => recordedEvents.value.length)
  const hasActiveNotes = computed(() => activeNotes.value.size > 0)

  // Gestionnaires d'√©v√©nements globaux
  function handleRecordingStart(event) {
    const mode = event.detail?.mode || projectStore.userPreferences.keyboard.recordingMode || 'merge'
    console.log('üé§ √âv√©nement de d√©but d\'enregistrement re√ßu:', event.detail, 'mode:', mode)
    startRecording(null, mode)
  }

  function handleRecordingStop(event) {
    console.log('üé§ √âv√©nement d\'arr√™t d\'enregistrement re√ßu')
    if (isRecording.value) {
      const mode = event.detail?.mode || projectStore.userPreferences.keyboard.recordingMode || 'merge'
      const events = stopRecording(mode)
      
      // D√©clencher plusieurs r√©activit√©s pour s'assurer que tout se met √† jour
      midiStore.triggerReactivity('midi-recording-stop')
      midiStore.forceCCUpdate() // Forcer sp√©cifiquement la mise √† jour des CC
      
      // √âmettre un √©v√©nement pour que les composants se mettent √† jour
      setTimeout(() => {
        window.dispatchEvent(new CustomEvent('midi-cc-updated', {
          detail: { eventCount: events.length }
        }))
      }, 100) // Petit d√©lai pour laisser le temps au store de se stabiliser
    }
  }

  // Configuration des √©v√©nements et monitoring
  onMounted(() => {
    window.addEventListener('midi-recording-start', handleRecordingStart)
    window.addEventListener('midi-recording-stop', handleRecordingStop)
    
    // D√©marrer le monitoring automatiquement si des inputs sont configur√©s
    setupMidiMonitoring()
  })

  // Watcher pour reconfigurer le monitoring quand les inputs ou √©tats Record/Monitor changent
  watch(() => midiStore.tracks.map(t => ({
    midiInput: t.midiInput,
    record: t.record,
    monitor: t.monitor
  })), () => {
    console.log('üîÑ Inputs MIDI ou √©tats Record/Monitor chang√©s, reconfiguration...')
    setupMidiMonitoring()
  }, { deep: true })

  // Nettoyage
  onUnmounted(() => {
    window.removeEventListener('midi-recording-start', handleRecordingStart)
    window.removeEventListener('midi-recording-stop', handleRecordingStop)
    
    clearMidiInputListeners()
    if (isRecording.value) {
      stopRecording()
    }
  })

  return {
    // √âtat
    isRecording,
    isRecordArmed,
    recordingTrackId,
    recordedEvents,
    recordedEventCount,
    hasActiveNotes,

    // Actions
    startRecording,
    stopRecording,
    setRecordArmed,
    toggleRecordArmed,
    setupMidiInputListening,
    setupMidiMonitoring,
    clearMidiInputListeners,

    // Utilitaires
    handleMidiMessage
  }
}